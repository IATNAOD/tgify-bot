# 1.0.0

> Development of this library starts from [telegraf@4.16.0](https://github.com/telegraf/telegraf/blob/v4/release-notes/4.16.0.md)

## Support for custom buttons for reply and inline keyboards

```TS
const { Tgify, Markup } = require("@tgify/tgify");

const BOT_TOKEN = "xxx:xxx";

const bot = new Tgify(BOT_TOKEN);

bot.start((ctx) =>
	ctx.reply("Start", {
		reply_markup: Markup.keyboard([
			[
				Markup.button.text("primary", false, {
					style: "primary",
					icon_custom_emoji_id: "5359536263856667601",
				}),
				Markup.button.text("danger", false, {
					style: "danger",
					icon_custom_emoji_id: "5359397703916730925",
				}),
				Markup.button.text("success", false, {
					style: "success",
					icon_custom_emoji_id: "5411457217259911292",
				}),
			],
			[
				Markup.button.text("Only style", false, {
					style: "success",
				}),
				Markup.button.text("Only emoji", false, {
					icon_custom_emoji_id: "5357199488115030155",
				}),
				Markup.button.text("Default", false, {}),
			],
		]).reply_markup,
	}),
);
bot.help((ctx) =>
	ctx.reply("Help", {
		reply_markup: Markup.inlineKeyboard([
			[
				Markup.button.callback("primary", "1", false, {
					style: "primary",
					icon_custom_emoji_id: "5359536263856667601",
				}),
				Markup.button.callback("danger", "1", false, {
					style: "danger",
					icon_custom_emoji_id: "5359397703916730925",
				}),
				Markup.button.callback("success", "1", false, {
					style: "success",
					icon_custom_emoji_id: "5411457217259911292",
				}),
			],
			[
				Markup.button.callback("Only style", "1", false, {
					style: "success",
				}),
				Markup.button.callback("Only emoji", "1", false, {
					icon_custom_emoji_id: "5357199488115030155",
				}),
				Markup.button.callback("Default", "1", false, {}),
			],
		]).reply_markup,
	}),
);

bot.launch();

// Enable graceful stop
process.once("SIGINT", () => bot.stop("SIGINT"));
process.once("SIGTERM", () => bot.stop("SIGTERM"));
```

## Expanded support for the local Bot API

- Previously, you could use the local Bot API for webhooks over HTTP only if you were using some external tool:

  ```TS
  const { Tgify } = require("@tgify/tgify");
  const Fastify = require("fastify");

  const BOT_TOKEN = "xxx:xxx";

  const bot = new Tgify(BOT_TOKEN, { telegram: { apiRoot: "http://192.168.0.77:8081" } });

  bot.start((ctx) => ctx.reply("Start"));
  bot.help((ctx) => ctx.reply("Help"));

  const fastify = Fastify({ trustProxy: true });

  fastify.post(`/${bot.secretPathComponent()}`, async (req, res) => {
  	try {
  		let body = req.body || "";
  		let update;

  		if (req.body != null) {
  			if (body instanceof Buffer) body = String(req.body);
  			if (typeof body === "string") body = JSON.parse(body);

  			update = body;
  		} else {
  			for await (const chunk of req) body += String(chunk);

  			update = JSON.parse(body);
  		}

  		bot.handleUpdate(update);

  		return res.code(200).send();
  	} catch (error) {
  		return res.code(415).send();
  	}
  });

  fastify.listen({ host: "0.0.0.0", port: "8001" }).then((address) => {
  	console.log(`Webhook server start at ${address}`);
  });

  bot.telegram
  	.setWebhook(`http://192.168.0.123:8001/${bot.secretPathComponent()}`, {
  		allowed_updates: ["message", "callback_query"],
  	})
  	.then(() => {
  		console.log("Webhook set successfully");
  	});
  ```

- You can now use launch to work with the local Bot API via webhook over HTTP:

  ```TS
  const { Tgify } = require("@tgify/tgify");

  const BOT_TOKEN = "xxx:xxx";

  const bot = new Tgify(BOT_TOKEN, { telegram: { apiRoot: "http://192.168.0.77:8081" } });

  bot.start((ctx) => ctx.reply("Start"));
  bot.help((ctx) => ctx.reply("Help"));

  bot.launch({
  	webhook: {
  		port: 3000,
  		local: true, // should be set for use http instead of https for local bot api
  		host: "0.0.0.0",
  		domain: "192.168.0.123:3000",
  	},
  });

  // Enable graceful stop
  process.once("SIGINT", () => bot.stop("SIGINT"));
  process.once("SIGTERM", () => bot.stop("SIGTERM"));
  ```

## Introducing Tgify v2

Over the next few months, I plan to focus primarily on refining the API to catch up from the currently supported version 7.1 to 9.x
